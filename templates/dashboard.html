<div class="dashboard">

  <h1>ğŸ“Š ì‹œìŠ¤í…œ ëŒ€ì‹œë³´ë“œ</h1>

  <!-- KPI Cards -->
  <div class="stats-grid">
    <div class="stat-card">
      <div class="stat-label">ì´ ë¬¸ì„œ ìˆ˜</div>
      <div class="stat-value" id="totalDocs">-</div>
    </div>
    <div class="stat-card success">
      <div class="stat-label">ì •ìƒ ì²˜ë¦¬</div>
      <div class="stat-value" id="successDocs">-</div>
    </div>
    <div class="stat-card warning">
      <div class="stat-label">ì¤‘ë³µ íŒŒì¼</div>
      <div class="stat-value" id="dupDocs">-</div>
    </div>
    <div class="stat-card error">
      <div class="stat-label">ì—ëŸ¬ ë°œìƒ</div>
      <div class="stat-value" id="errorDocs">-</div>
    </div>
  </div>

  <!-- Pipeline Control -->
  <div class="card">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <h2>ğŸš€ íŒŒì´í”„ë¼ì¸ ì œì–´</h2>
        <div id="pipelineStatus" style="display: flex; align-items: center; gap: 8px;">
            <div id="pipelineIndicator" style="width: 10px; height: 10px; border-radius: 50%; background: #94a3b8;"></div>
            <span id="pipelineStatusText" style="font-size: 14px; color: var(--text-muted);">í™•ì¸ ì¤‘...</span>
        </div>
    </div>
    
    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 16px;">
        <div class="pipeline-stat">
            <span class="pipeline-stat-label">ìƒíƒœ</span>
            <span class="pipeline-stat-value" id="pipelineRunning">-</span>
        </div>
        <div class="pipeline-stat">
            <span class="pipeline-stat-label">Observer</span>
            <span class="pipeline-stat-value" id="observerAlive">-</span>
        </div>
        <div class="pipeline-stat">
            <span class="pipeline-stat-label">ì‹œì‘ ì‹œê°„</span>
            <span class="pipeline-stat-value" id="pipelineStartedAt">-</span>
        </div>
        <div class="pipeline-stat">
            <span class="pipeline-stat-label">Uptime</span>
            <span class="pipeline-stat-value" id="pipelineUptime">-</span>
        </div>
    </div>
    
    <div style="display: flex; gap: 12px;">
        <button class="btn btn-success" onclick="pipelineAction('start')" id="btnStart">
            â–¶ï¸ ì‹œì‘
        </button>
        <button class="btn btn-warning" onclick="pipelineAction('stop')" id="btnStop">
            â¹ï¸ ì¤‘ì§€
        </button>
        <button class="btn btn-secondary" onclick="pipelineAction('restart')" id="btnRestart">
            ğŸ”„ ì¬ì‹œì‘
        </button>
    </div>
  </div>

  <!-- System Status -->
  <div class="card">
    <h2>âš™ ì‹œìŠ¤í…œ ìƒíƒœ</h2>
    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px;">
        <div style="display: flex; align-items: center; gap: 8px;">
            <div id="ingestIndicator" style="width: 8px; height: 8px; border-radius: 50%; background: #94a3b8;"></div>
            <span>Ingest Service</span>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
            <div style="width: 8px; height: 8px; border-radius: 50%; background: #22c55e; box-shadow: 0 0 8px #22c55e;"></div>
            <span>Vector DB (Qdrant)</span>
        </div>
        <div style="display: flex; align-items: center; gap: 8px;">
            <span style="opacity: 0.7;">ëª¨ë¸:</span>
            <b>openai / ollama</b>
        </div>
    </div>
  </div>

  <!-- Recent Logs -->
  <div class="card">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <h2>ğŸ“œ ì‹¤ì‹œê°„ ë¡œê·¸</h2>
        <span style="font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 4px;">
            <span style="display: block; width: 6px; height: 6px; background: #ef4444; border-radius: 50%; animation: blink 1s infinite;"></span>
            Live
        </span>
    </div>
    <div class="log-container" id="logBox">
        loading...
    </div>
  </div>

</div>

<style>
@keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.4; }
    100% { opacity: 1; }
}

/* ìƒˆ ë¡œê·¸ í•˜ì´ë¼ì´íŠ¸ ì• ë‹ˆë©”ì´ì…˜ */
@keyframes newLogHighlight {
    0% { background-color: rgba(59, 130, 246, 0.3); }
    100% { background-color: transparent; }
}

.log-entry.new {
    animation: newLogHighlight 1s ease-out;
}

.log-entry.warning {
    color: #f59e0b;
}

.log-container {
    max-height: 400px;
    overflow-y: auto;
    scroll-behavior: smooth;
}

.pipeline-stat {
    background: var(--bg-dark);
    padding: 12px 16px;
    border-radius: 8px;
    text-align: center;
}

.pipeline-stat-label {
    display: block;
    font-size: 11px;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 4px;
}

.pipeline-stat-value {
    display: block;
    font-size: 14px;
    font-weight: 600;
    color: var(--text-main);
}

.btn-success {
    background: linear-gradient(135deg, #22c55e, #16a34a);
    color: white;
}

.btn-success:hover {
    filter: brightness(1.1);
}

.btn-warning {
    background: linear-gradient(135deg, #f59e0b, #d97706);
    color: white;
}

.btn-warning:hover {
    filter: brightness(1.1);
}

.btn-secondary {
    background: var(--bg-card-hover);
    color: var(--text-main);
    border: 1px solid var(--border-color);
}

.btn {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    border: none;
    font-size: 14px;
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
</style>

<script>
async function loadDashboard() {
  try {
    const res = await fetch("/api/dashboard/summary");
    const data = await res.json();

    document.getElementById("totalDocs").textContent = data.total;
    document.getElementById("successDocs").textContent = data.success;
    document.getElementById("dupDocs").textContent = data.duplicated;
    document.getElementById("errorDocs").textContent = data.error;
  } catch (e) {
    console.error(e);
  }
}

// ì´ˆê¸° ë¡œê·¸ ë¡œë“œ (ìµœê·¼ 50ì¤„)
async function loadInitialLogs() {
  try {
    const res = await fetch("/api/logs?limit=50");
    const data = await res.json();

    const box = document.getElementById("logBox");
    box.innerHTML = data.logs.map(line => formatLogLine(line)).join("");
    
    // ìŠ¤í¬ë¡¤ì„ ë§¨ ì•„ë˜ë¡œ
    box.scrollTop = box.scrollHeight;
  } catch(e) { console.error(e); }

  // iframe ë†’ì´ ìë™ ì¬ì¡°ì • íŠ¸ë¦¬ê±°
  window.dispatchEvent(new Event("resize"));
}

// ë¡œê·¸ ë¼ì¸ í¬ë§·íŒ…
function formatLogLine(line) {
    let className = "log-entry";
    if (line.includes("[ERROR]")) className += " error";
    else if (line.includes("[INFO]")) className += " info";
    else if (line.includes("[SUCCESS]") || line.includes("[OK]")) className += " success";
    else if (line.includes("[WARN]")) className += " warning";
    
    return `<div class="${className}">${escapeHtml(line)}</div>`;
}

// HTML ì´ìŠ¤ì¼€ì´í”„
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// SSE ì‹¤ì‹œê°„ ë¡œê·¸ ìŠ¤íŠ¸ë¦¬ë°
let logEventSource = null;
const MAX_LOG_LINES = 200;  // ìµœëŒ€ ë¡œê·¸ ë¼ì¸ ìˆ˜

function startLogStream() {
    if (logEventSource) {
        logEventSource.close();
    }
    
    logEventSource = new EventSource("/api/logs/stream");
    const box = document.getElementById("logBox");
    
    logEventSource.onmessage = function(event) {
        const line = event.data;
        if (!line.trim()) return;
        
        // ìƒˆ ë¡œê·¸ ë¼ì¸ ì¶”ê°€
        const newLine = document.createElement('div');
        newLine.innerHTML = formatLogLine(line).replace('<div class="', '').replace('</div>', '');
        newLine.className = formatLogLine(line).match(/class="([^"]+)"/)?.[1] || 'log-entry';
        newLine.textContent = line;
        
        // í´ë˜ìŠ¤ ì ìš©
        if (line.includes("[ERROR]")) newLine.classList.add("error");
        else if (line.includes("[INFO]")) newLine.classList.add("info");
        else if (line.includes("[SUCCESS]") || line.includes("[OK]")) newLine.classList.add("success");
        else if (line.includes("[WARN]")) newLine.classList.add("warning");
        
        newLine.classList.add("log-entry", "new");
        box.appendChild(newLine);
        
        // ìµœëŒ€ ë¼ì¸ ìˆ˜ ì œí•œ
        while (box.children.length > MAX_LOG_LINES) {
            box.removeChild(box.firstChild);
        }
        
        // ìë™ ìŠ¤í¬ë¡¤ (ì‚¬ìš©ìê°€ ìœ„ë¡œ ìŠ¤í¬ë¡¤í•˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ)
        const isScrolledToBottom = box.scrollHeight - box.clientHeight <= box.scrollTop + 50;
        if (isScrolledToBottom) {
            box.scrollTop = box.scrollHeight;
        }
        
        // ìƒˆ ë¡œê·¸ ì• ë‹ˆë©”ì´ì…˜ ì œê±°
        setTimeout(() => newLine.classList.remove("new"), 1000);
    };
    
    logEventSource.onerror = function(e) {
        console.error("Log stream error:", e);
        // ì¬ì—°ê²° ì‹œë„
        setTimeout(() => {
            if (logEventSource.readyState === EventSource.CLOSED) {
                startLogStream();
            }
        }, 3000);
    };
}

// í˜ì´ì§€ ì¢…ë£Œ ì‹œ SSE ì—°ê²° ë‹«ê¸°
window.addEventListener('beforeunload', function() {
    if (logEventSource) {
        logEventSource.close();
    }
});

// Pipeline functions
async function loadPipelineStatus() {
    try {
        const res = await fetch('/pipeline/status');
        const data = await res.json();
        
        const isRunning = data.running && data.observer_alive;
        
        // Update indicator
        const indicator = document.getElementById('pipelineIndicator');
        const statusText = document.getElementById('pipelineStatusText');
        const ingestIndicator = document.getElementById('ingestIndicator');
        
        if (isRunning) {
            indicator.style.background = '#22c55e';
            indicator.style.boxShadow = '0 0 8px #22c55e';
            statusText.textContent = 'ì‹¤í–‰ ì¤‘';
            statusText.style.color = '#22c55e';
            ingestIndicator.style.background = '#22c55e';
            ingestIndicator.style.boxShadow = '0 0 8px #22c55e';
        } else {
            indicator.style.background = '#ef4444';
            indicator.style.boxShadow = '0 0 8px #ef4444';
            statusText.textContent = 'ì¤‘ì§€ë¨';
            statusText.style.color = '#ef4444';
            ingestIndicator.style.background = '#ef4444';
            ingestIndicator.style.boxShadow = 'none';
        }
        
        // Update stats
        document.getElementById('pipelineRunning').textContent = data.running ? 'ì‹¤í–‰' : 'ì¤‘ì§€';
        document.getElementById('pipelineRunning').style.color = data.running ? '#22c55e' : '#ef4444';
        
        document.getElementById('observerAlive').textContent = data.observer_alive ? 'í™œì„±' : 'ë¹„í™œì„±';
        document.getElementById('observerAlive').style.color = data.observer_alive ? '#22c55e' : '#ef4444';
        
        if (data.started_at) {
            const startTime = new Date(data.started_at);
            document.getElementById('pipelineStartedAt').textContent = startTime.toLocaleTimeString('ko-KR');
        } else {
            document.getElementById('pipelineStartedAt').textContent = '-';
        }
        
        if (data.uptime_seconds) {
            const hours = Math.floor(data.uptime_seconds / 3600);
            const minutes = Math.floor((data.uptime_seconds % 3600) / 60);
            const seconds = Math.floor(data.uptime_seconds % 60);
            document.getElementById('pipelineUptime').textContent = 
                `${hours}h ${minutes}m ${seconds}s`;
        } else {
            document.getElementById('pipelineUptime').textContent = '-';
        }
        
        // Update button states
        document.getElementById('btnStart').disabled = isRunning;
        document.getElementById('btnStop').disabled = !isRunning;
        
    } catch (e) {
        console.error('Failed to load pipeline status:', e);
        document.getElementById('pipelineStatusText').textContent = 'ì—°ê²° ì‹¤íŒ¨';
        document.getElementById('pipelineStatusText').style.color = '#f59e0b';
    }
}

async function pipelineAction(action) {
    const btn = document.getElementById(`btn${action.charAt(0).toUpperCase() + action.slice(1)}`);
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = 'ì²˜ë¦¬ ì¤‘...';
    
    try {
        const res = await fetch(`/pipeline/${action}`, { method: 'POST' });
        const data = await res.json();
        
        showToast(`íŒŒì´í”„ë¼ì¸ ${action}: ${data.status}`);
        
        // Reload status after action
        setTimeout(loadPipelineStatus, 500);
        
    } catch (e) {
        console.error(`Pipeline ${action} failed:`, e);
        showToast(`íŒŒì´í”„ë¼ì¸ ${action} ì‹¤íŒ¨`, 'error');
    } finally {
        btn.innerHTML = originalText;
        btn.disabled = false;
    }
}

function showToast(message, type = 'success') {
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 20px;
        background: ${type === 'error' ? 'var(--error)' : type === 'warning' ? 'var(--warning)' : 'var(--success)'};
        color: white;
        border-radius: 8px;
        font-size: 14px;
        z-index: 1001;
        animation: slideIn 0.3s ease;
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.3s';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

loadDashboard();
loadInitialLogs();
loadPipelineStatus();

// SSE ì‹¤ì‹œê°„ ë¡œê·¸ ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘
startLogStream();

// ëŒ€ì‹œë³´ë“œì™€ íŒŒì´í”„ë¼ì¸ ìƒíƒœë§Œ ì£¼ê¸°ì ìœ¼ë¡œ ê°±ì‹ 
setInterval(loadDashboard, 10000);
setInterval(loadPipelineStatus, 5000);
</script>
