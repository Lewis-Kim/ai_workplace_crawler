<style>
  .dropzone {
    width: 80%;
    margin: 40px auto;
    padding: 60px;
    border: 3px dashed #4a90e2;
    border-radius: 12px;
    background: white;
    text-align: center;
    color: #666;
    font-size: 18px;
    cursor: pointer;
  }
  .dropzone.dragover {
    background: #eaf3ff;
    border-color: #1c6fd5;
    color: #1c6fd5;
  }
  .status {
    width: 80%;
    margin: 20px auto;
    background: #fff;
    padding: 20px;
    border-radius: 8px;
    font-size: 14px;
  }
  .file-item {
    margin-bottom: 6px;
  }
  #logBox {
    width: 80%;
    margin: 20px auto;
    background: #111;
    color: #ddd;
    padding: 16px;
    border-radius: 8px;
    font-size: 12px;
    max-height: 300px;
    overflow: auto;
  }
  .error { color: #ff6b6b; }
  .info { color: #6bc1ff; }
</style>

<h1>ğŸ“¤ Drag & Drop ì—…ë¡œë“œ</h1>

<div class="dropzone" id="dropzone">
  ğŸ“‚ íŒŒì¼ ë˜ëŠ” í´ë”ë¥¼ ì—¬ê¸°ì— ë“œë˜ê·¸ì•¤ë“œë¡­ í•˜ì„¸ìš”
</div>

<div class="status" id="status"></div>

<h2 style="width:80%;margin:30px auto 10px;">ğŸ“œ System Logs</h2>
<pre id="logBox">loading...</pre>

<script>
const dropzone = document.getElementById("dropzone");
const statusBox = document.getElementById("status");

["dragenter", "dragover"].forEach(evt => {
  dropzone.addEventListener(evt, e => {
    e.preventDefault();
    dropzone.classList.add("dragover");
  });
});

["dragleave", "drop"].forEach(evt => {
  dropzone.addEventListener(evt, e => {
    e.preventDefault();
    dropzone.classList.remove("dragover");
  });
});

dropzone.addEventListener("drop", async (e) => {
  const items = e.dataTransfer.items;
  if (!items) return;

  const files = [];

  async function traverse(entry, path = "") {
    if (entry.isFile) {
      await new Promise(resolve => {
        entry.file(file => {
          file.relativePath = path + file.name;
          files.push(file);
          resolve();
        });
      });
    } else if (entry.isDirectory) {
      const reader = entry.createReader();
      await new Promise(resolve => {
        reader.readEntries(async entries => {
          for (const ent of entries) {
            await traverse(ent, path + entry.name + "/");
          }
          resolve();
        });
      });
    }
  }

  for (const item of items) {
    const entry = item.webkitGetAsEntry();
    if (entry) await traverse(entry);
  }

  if (files.length === 0) {
    alert("ì—…ë¡œë“œí•  íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.");
    return;
  }

  statusBox.innerHTML = "â³ ì—…ë¡œë“œ ì¤‘...";

  const formData = new FormData();
  files.forEach(f => {
    formData.append("files", f, f.relativePath);
  });

  try {
    const res = await fetch("/files/upload-folder-raw", {
      method: "POST",
      body: formData
    });

    const data = await res.json();

    statusBox.innerHTML = `
      âœ… ì—…ë¡œë“œ ì™„ë£Œ<br/>
      íŒŒì¼ ìˆ˜: ${data.files_count}
      <hr/>
      ${data.files.map(f => `<div class="file-item">${f}</div>`).join("")}
    `;

    // ğŸ”¥ iframe ë†’ì´ ì¬ê³„ì‚° íŠ¸ë¦¬ê±°
    window.dispatchEvent(new Event("resize"));

  } catch (err) {
    console.error(err);
    statusBox.innerHTML = "âŒ ì—…ë¡œë“œ ì‹¤íŒ¨";
  }
});
</script>

<script>
async function loadLogs() {
  const res = await fetch("/api/logs?limit=300");
  const data = await res.json();

  const box = document.getElementById("logBox");
  box.innerHTML = data.logs.map(line => {
    if (line.includes("[ERROR]")) return `<span class="error">${line}</span>`;
    if (line.includes("[INFO]")) return `<span class="info">${line}</span>`;
    return line;
  }).join("\n");

  // ğŸ”¥ ë¡œê·¸ ê°±ì‹  ì‹œ iframe ë†’ì´ ë°˜ì˜
  window.dispatchEvent(new Event("resize"));
}

setInterval(loadLogs, 2000);
loadLogs();
</script>
